# short holds the result we want to print
# full holds the full path up to the current segment
# part holds the current segment, will get as few characters as
# possible from cur, which is the full current segment

local short full part cur
local first
local -a split    # the array we loop over

1=${1:-$PWD}

if [[ $1 == / ]]; then
  REPLY=/
  return 0
fi

# We do the (D) expansion right here and
# handle it later if it had any effect
split=(${(s:/:)${(Q)${(D)1:-$1}}})

# Handling. Perhaps NOT use (D) above and check after shortening?
if [[ $split[1] = \~* ]]; then
  # named directory we skip shortening the first element
  # and manually prepend the first element to the return value
  first=$split[1]
  # full should already contain the first
  # component since we don't start there
  full=$~split[1]
  shift split
fi

for cur ($split) {
  part=/
  while {
           part+=$cur[1]
           cur=$cur[2,-1]
           local -a glob
           glob=( $full/$part*(-/N) )
           # continue adding if more than one directory matches or
           # the current string is . or ..
           # but stop if there are no more characters to add
           (( $#glob > 1 )) || [[ $part == (.|..) ]] && (( $#cur > 0 ))
        } { # this is a do-while loop
  }
  full+=$part$cur
  short+=$part
}
REPLY=$first$short
return 0
